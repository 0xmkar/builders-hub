---
title: Deploy Smart Contracts
description: Write, test, and deploy Solidity smart contracts on Avalanche C-Chain
---

# Deploy Smart Contracts on Avalanche

Learn to write, test, and deploy Solidity smart contracts on Avalanche C-Chain. This guide covers the complete development workflow from writing your first contract to production deployment.

## What You'll Learn

By the end of this guide, you'll know how to:
- Write secure Solidity smart contracts
- Set up a complete development environment
- Test contracts thoroughly before deployment
- Deploy to Avalanche testnet and mainnet
- Verify and interact with deployed contracts

## Prerequisites

- Basic programming knowledge
- Understanding of blockchain concepts
- Node.js and npm installed
- MetaMask or Core wallet configured

## Step 1: Set Up Development Environment

### Install Development Tools

```bash
# Install Node.js and npm (if not already installed)
# Visit: https://nodejs.org/

# Create new project directory
mkdir my-smart-contracts
cd my-smart-contracts

# Initialize npm project
npm init -y

# Install Hardhat (recommended framework)
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox

# Initialize Hardhat project
npx hardhat init
```

### Configure Hardhat for Avalanche

Update `hardhat.config.js`:

```javascript
require("@nomicfoundation/hardhat-toolbox");
require("dotenv").config();

module.exports = {
  solidity: {
    version: "0.8.19",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  networks: {
    // Local development network
    hardhat: {
      chainId: 31337
    },
    // Avalanche Fuji Testnet
    fuji: {
      url: "https://api.avax-test.network/ext/bc/C/rpc",
      gasPrice: 225000000000,
      chainId: 43113,
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : []
    },
    // Avalanche Mainnet
    mainnet: {
      url: "https://api.avax.network/ext/bc/C/rpc",
      gasPrice: 225000000000,
      chainId: 43114,
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : []
    }
  },
  etherscan: {
    apiKey: {
      avalanche: process.env.SNOWTRACE_API_KEY,
      avalancheFujiTestnet: process.env.SNOWTRACE_API_KEY
    }
  }
};
```

### Environment Variables

Create `.env` file:

```bash
# Private key for deployment (without 0x prefix)
PRIVATE_KEY=your_private_key_here

# Snowtrace API key for contract verification
SNOWTRACE_API_KEY=your_api_key_here
```

## Step 2: Write Your Smart Contract

### Simple Storage Contract

Create `contracts/SimpleStorage.sol`:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract SimpleStorage {
    uint256 private storedData;
    address public owner;
    
    event DataStored(uint256 newValue, address storedBy);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    function set(uint256 x) public {
        storedData = x;
        emit DataStored(x, msg.sender);
    }
    
    function get() public view returns (uint256) {
        return storedData;
    }
    
    function adminSet(uint256 x) public onlyOwner {
        storedData = x;
        emit DataStored(x, msg.sender);
    }
}
```

### ERC-20 Token Contract

Create `contracts/MyToken.sol`:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyToken is ERC20, Ownable {
    uint256 public constant MAX_SUPPLY = 1000000 * 10**18; // 1 million tokens
    
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 100000 * 10**18); // Initial mint: 100k tokens
    }
    
    function mint(address to, uint256 amount) public onlyOwner {
        require(totalSupply() + amount <= MAX_SUPPLY, "Exceeds max supply");
        _mint(to, amount);
    }
    
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }
}
```

### NFT Contract

Create `contracts/MyNFT.sol`:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract MyNFT is ERC721, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;
    
    uint256 public constant MAX_SUPPLY = 10000;
    uint256 public mintPrice = 0.1 ether;
    
    mapping(uint256 => string) private _tokenURIs;
    
    constructor() ERC721("MyNFT", "MNFT") {}
    
    function mint(address to, string memory tokenURI) public payable {
        require(_tokenIds.current() < MAX_SUPPLY, "Max supply reached");
        require(msg.value >= mintPrice, "Insufficient payment");
        
        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();
        
        _mint(to, newTokenId);
        _setTokenURI(newTokenId, tokenURI);
    }
    
    function _setTokenURI(uint256 tokenId, string memory tokenURI) internal {
        _tokenURIs[tokenId] = tokenURI;
    }
    
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "Token does not exist");
        return _tokenURIs[tokenId];
    }
    
    function withdraw() public onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }
}
```

## Step 3: Write Tests

### Test Setup

Create `test/SimpleStorage.test.js`:

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("SimpleStorage", function () {
  let SimpleStorage;
  let simpleStorage;
  let owner;
  let addr1;
  let addr2;

  beforeEach(async function () {
    SimpleStorage = await ethers.getContractFactory("SimpleStorage");
    [owner, addr1, addr2] = await ethers.getSigners();
    simpleStorage = await SimpleStorage.deploy();
  });

  describe("Deployment", function () {
    it("Should set the right owner", async function () {
      expect(await simpleStorage.owner()).to.equal(owner.address);
    });

    it("Should initialize with zero value", async function () {
      expect(await simpleStorage.get()).to.equal(0);
    });
  });

  describe("Transactions", function () {
    it("Should store the value", async function () {
      await simpleStorage.set(42);
      expect(await simpleStorage.get()).to.equal(42);
    });

    it("Should emit DataStored event", async function () {
      await expect(simpleStorage.set(42))
        .to.emit(simpleStorage, "DataStored")
        .withArgs(42, owner.address);
    });

    it("Should only allow owner to use adminSet", async function () {
      await expect(simpleStorage.connect(addr1).adminSet(42))
        .to.be.revertedWith("Only owner can call this function");
    });
  });
});
```

### Run Tests

```bash
# Run all tests
npx hardhat test

# Run specific test file
npx hardhat test test/SimpleStorage.test.js

# Run tests with gas reporting
REPORT_GAS=true npx hardhat test
```

## Step 4: Deploy to Testnet

### Get Test Funds

1. Visit [Avalanche Faucet](https://faucet.avax.network/)
2. Connect your wallet
3. Request test AVAX for Fuji testnet

### Create Deployment Script

Create `scripts/deploy.js`:

```javascript
const { ethers } = require("hardhat");

async function main() {
  const [deployer] = await ethers.getSigners();
  
  console.log("Deploying contracts with the account:", deployer.address);
  console.log("Account balance:", (await deployer.getBalance()).toString());

  // Deploy SimpleStorage
  const SimpleStorage = await ethers.getContractFactory("SimpleStorage");
  const simpleStorage = await SimpleStorage.deploy();
  await simpleStorage.deployed();
  console.log("SimpleStorage deployed to:", simpleStorage.address);

  // Deploy MyToken
  const MyToken = await ethers.getContractFactory("MyToken");
  const myToken = await MyToken.deploy("My Awesome Token", "MAT");
  await myToken.deployed();
  console.log("MyToken deployed to:", myToken.address);

  // Deploy MyNFT
  const MyNFT = await ethers.getContractFactory("MyNFT");
  const myNFT = await MyNFT.deploy();
  await myNFT.deployed();
  console.log("MyNFT deployed to:", myNFT.address);

  // Verify deployment
  console.log("\nVerifying contracts...");
  
  try {
    await hre.run("verify:verify", {
      address: simpleStorage.address,
      constructorArguments: [],
    });
    console.log("SimpleStorage verified");
  } catch (error) {
    console.log("SimpleStorage verification failed:", error.message);
  }

  try {
    await hre.run("verify:verify", {
      address: myToken.address,
      constructorArguments: ["My Awesome Token", "MAT"],
    });
    console.log("MyToken verified");
  } catch (error) {
    console.log("MyToken verification failed:", error.message);
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

### Deploy to Fuji Testnet

```bash
# Deploy to Fuji testnet
npx hardhat run scripts/deploy.js --network fuji

# Expected output:
# Deploying contracts with the account: 0x...
# Account balance: 1000000000000000000
# SimpleStorage deployed to: 0x...
# MyToken deployed to: 0x...
# MyNFT deployed to: 0x...
```

## Step 5: Verify Contracts

### Automatic Verification

```bash
# Install verification plugin
npm install --save-dev @nomiclabs/hardhat-etherscan

# Verify contract manually
npx hardhat verify --network fuji CONTRACT_ADDRESS
```

### Manual Verification on Snowtrace

1. Go to [Snowtrace](https://testnet.snowtrace.io/)
2. Search for your contract address
3. Click "Contract" tab
4. Click "Verify and Publish"
5. Upload your contract source code

## Step 6: Interact with Deployed Contracts

### Using Hardhat Console

```bash
# Start Hardhat console
npx hardhat console --network fuji

# In the console:
const SimpleStorage = await ethers.getContractFactory("SimpleStorage");
const simpleStorage = await SimpleStorage.attach("YOUR_CONTRACT_ADDRESS");

// Call functions
await simpleStorage.set(42);
const value = await simpleStorage.get();
console.log("Stored value:", value.toString());
```

### Using Web3 Interface

```javascript
// Frontend interaction example
import { ethers } from 'ethers';

const contractAddress = "YOUR_CONTRACT_ADDRESS";
const contractABI = [
  "function set(uint256 x) public",
  "function get() public view returns (uint256)",
  "event DataStored(uint256 newValue, address storedBy)"
];

async function interactWithContract() {
  if (window.ethereum) {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    const contract = new ethers.Contract(contractAddress, contractABI, signer);
    
    // Set value
    const tx = await contract.set(42);
    await tx.wait();
    
    // Get value
    const value = await contract.get();
    console.log("Value:", value.toString());
  }
}
```

## Step 7: Deploy to Mainnet

### Pre-Deployment Checklist

Before deploying to mainnet:
- [ ] Comprehensive testing completed
- [ ] Security audit performed
- [ ] Gas optimization implemented
- [ ] Error handling robust
- [ ] Documentation complete
- [ ] Sufficient AVAX for deployment

### Mainnet Deployment

```bash
# Deploy to mainnet (use with caution!)
npx hardhat run scripts/deploy.js --network mainnet
```

## Security Best Practices

### Code Security

```solidity
// Use checks-effects-interactions pattern
function withdraw() public {
    uint256 amount = balances[msg.sender];
    require(amount > 0, "No balance to withdraw");
    
    balances[msg.sender] = 0; // Effects
    
    (bool success, ) = msg.sender.call{value: amount}(""); // Interactions
    require(success, "Transfer failed");
}

// Use ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract MyContract is ReentrancyGuard {
    function sensitiveFunction() public nonReentrant {
        // Function logic
    }
}

// Validate inputs
function transfer(address to, uint256 amount) public {
    require(to != address(0), "Cannot transfer to zero address");
    require(amount > 0, "Amount must be greater than zero");
    require(balances[msg.sender] >= amount, "Insufficient balance");
    // Transfer logic
}
```

### Gas Optimization

```solidity
// Use events for logging instead of storage
event Transfer(address indexed from, address indexed to, uint256 value);

// Pack structs efficiently
struct User {
    uint128 balance;  // Instead of uint256
    uint64 timestamp; // Instead of uint256
    bool active;      // Packed with above
}

// Use libraries for common operations
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }
}
```

## Advanced Topics

### Proxy Contracts

```solidity
// Upgradeable contract pattern
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyUpgradeableContract is Initializable {
    function initialize() public initializer {
        // Initialization logic
    }
}
```

### Factory Patterns

```solidity
// Contract factory
contract TokenFactory {
    event TokenCreated(address tokenAddress, address owner);
    
    function createToken(string memory name, string memory symbol) public {
        MyToken newToken = new MyToken(name, symbol);
        newToken.transferOwnership(msg.sender);
        emit TokenCreated(address(newToken), msg.sender);
    }
}
```

## Troubleshooting

### Common Issues

**Deployment Failures**:
- Check network configuration
- Ensure sufficient gas and AVAX balance
- Verify contract compilation

**Transaction Reverts**:
- Check require statements
- Validate function parameters
- Ensure proper access controls

**Gas Estimation Errors**:
- Review gas limit settings
- Optimize contract code
- Check for infinite loops

## Next Steps

<Cards>
<Card title="Advanced Patterns" description="Learn design patterns and best practices" href="/docs/dapps/smart-contract-dev" />
<Card title="DeFi Development" description="Build decentralized finance applications" href="/docs/dapps/advanced-tutorials" />
<Card title="Cross-Chain Contracts" description="Enable cross-chain functionality" href="/docs/cross-chain" />
<Card title="Contract Verification" description="Verify contracts on block explorers" href="/docs/dapps/verify-contract" />
</Cards>

## Resources

- [Solidity Documentation](https://docs.soliditylang.org/)
- [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/)
- [Hardhat Documentation](https://hardhat.org/docs)
- [Avalanche Smart Contract Examples](https://github.com/ava-labs/avalanche-smart-contract-quickstart)
- [Smart Contract Security](https://consensys.github.io/smart-contract-best-practices/) 