---
title: Genesis Breakdown
description: Deep dive into the genesis file structure - understand how Subnet-EVM chains initialize with predeployed contracts, fee configurations, and cross-chain messaging setup for permissioned L1s.
updated: 2025-03-19
authors: [nicolasarnedo]
icon: BookOpen
---


### What is a genesis file?

The genesis file defines the very first block of your Subnet-EVM chain and its initial state. It enables EVM features, sets economic parameters (fees and gas), fixes the start time, etc...

Additionally, in the context of Avalanche, it is **set by default to pre-deploy well-known contracts**. Lets take a look at which ones:

## Predeployed Contracts & Allocation

The `alloc` section seeds balances and deploys bytecode at fixed addresses before block 0, so they exist from the first block. 

Additional contracts are also deployed by default (*multicall3, create2, wrapped native tokens...*), but we will not dive into them in this guide as they are not essential for understanding permissioned L1s.

- **BLOCKCHAIN_DEPLOYER_ADDRESS** - Subnet Owner Balance: `0xd3c21bcecceda1000000` wei = 1,000,000 native tokens (1e6 × 1e18) useful for funded deployer/faucet account

- **TransparentUpgradeableProxy** *(0xfacade00...00)* — Proxy bytecode that delegates calls to an implementation and is controlled by an admin. Storage slots (EIP‑1967) predefined in the contract:
    - `0x3608…bbc` (implementation): `0x1212121212121212121212121212121212121212` (placeholder implementation address)
    - `0xb531…103` (admin): `0xdad0000000000000000000000000000000000000` (the Proxy Admin address below).

- **Proxy Admin** *(0xdad00...00)* — Owns and manages upgrades of the proxy at `0xfacade…`

<div style={{ display: 'flex', justifyContent: 'center', margin: '2rem 0' }}>
  <img src="/common-images/permissioned-l1s/VMCGenesis.png" alt="VMC Proxy Deployment" style={{ width: '60%', height: 'auto' }} />
</div>

### Predeployed Contracts Structure

Here you can see the contracts we just mentioned and how they relate:

<div style={{ display: 'flex', justifyContent: 'center', margin: '2rem 0', width: '100%' }}>
  <div style={{ width: '90%', maxWidth: '1200px' }}>
    <Mermaid
      chart="
graph TD
  A[facade - TransparentUpgradeableProxy] --> B[0x1212... implementation placeholder]
  C[dad... ProxyAdmin] --> A
  G[CREATE2 Deployer] --> H[User contracts]
  I[Multicall3] --> H
  J[WNT] <--> K[Native token]
  
  A -.->|delegatecall| B
  C -.->|admin-of| A
  G -.->|deterministic deploys| H
  I -.->|batch read/exec| H
  
  classDef proxyStyle fill:#e1f5fe,stroke:#01579b,stroke-width:3px
  classDef utilityStyle fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
  
  class A,B,C proxyStyle
  class G,I,J,K utilityStyle
"
    />
  </div>
</div>

### Why Proxy Contracts as Predeployed?

The `convertSubnetToL1` process has limited transaction capacity during conversion. By predeploying proxy contracts, we ensure that essential infrastructure is available immediately after conversion without needing to deploy them in the constrained environment.

This approach makes the conversion process viable by:
- Providing immediate access to upgradable app logic through the proxy at `0xfacade…`
- Allowing the admin at `0xdad…` to wire up real implementations after conversion
- Ensuring basic blockchain functionality is available from day one

### Key Takeaways

- Upgradable app logic can be wired by upgrading the proxy at `0xfacade…` via the admin `0xdad…` to point to a real implementation.
- CREATE2 deployer, Multicall3 and Wrapped Native Tokens for basic out-of-the-box use of blockchains.
- Proxy contracts are predeployed to overcome limited transaction capacity during `convertSubnetToL1`.

